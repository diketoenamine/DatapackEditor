package zane1117.datapackeditor;

import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.World;
import org.bukkit.block.BlockState;
import org.bukkit.block.CommandBlock;
import org.bukkit.command.CommandExecutor;
import org.bukkit.entity.HumanEntity;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockDataMeta;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.java.JavaPlugin;

import javax.xml.crypto.Data;
import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

public final class DatapackEditor extends JavaPlugin {

    public static Logger LOGGER;

    public static DatapackEditor INSTANCE;
    public static HashMap<HumanEntity, DEEditorGui> guisAcceptingInput = new HashMap<>();

    @Override
    public void onEnable() {
        // Plugin startup logic
        this.getCommand("datapackeditor").setExecutor(new DECommand());
        this.getCommand("datapackeditor").setTabCompleter(new DETabCompletor());
        getServer().getPluginManager().registerEvents(new ChatEventListener(), this);
        LOGGER = this.getLogger();
        INSTANCE = this;
    }

    @Override
    public void onDisable() {
        // Plugin shutdown logic
    }

    public void registerThing(DEEditorGui gui) {
        getServer().getPluginManager().registerEvents(gui, this);
    }

    static void createDatapack(String name, World world) throws IOException {
        // Get and create datapack folder
        File worldFolder = world.getWorldFolder();
        File datapackFolder = new File(worldFolder, "datapacks/" + name);
        boolean result = datapackFolder.mkdirs();
        if (!result) {LOGGER.log(Level.SEVERE, "Error creating datapack "+name); return;}


        // Create pack.mcmeta file
        File mcmetaFile = new File(datapackFolder, "/pack.mcmeta");
        /*boolean fileResult = mcmetaFile.createNewFile();
        if (!fileResult) {LOGGER.log(Level.SEVERE, "Error creating datapack "+name); return;}*/
        FileWriter writer = new FileWriter(mcmetaFile);
        String mcmetaString = "{\n" +
                "    \"pack\": {\n" +
                "        \"pack_format\": 12,\n" +
                "        \"description\": \"Datapack generated by DatapackEditor\"\n" +
                "    }\n" +
                "}";
        writer.write(mcmetaString);
        writer.close();

        // Create functions directory
        File functionDirFile = new File(datapackFolder, "data/" + name + "/functions");
        boolean functionResult = functionDirFile.mkdirs();
        if (!functionResult) {LOGGER.log(Level.SEVERE, "Error creating datapack "+name); return;}
    }

    static void deleteDatapack(String name, World world) {
        // Get and delete datapack folder
        File worldFolder = world.getWorldFolder();
        File datapackFolder = new File(worldFolder, "datapacks/" + name);
        superDelete(datapackFolder);
    }

    static void superDelete(File folder) {
        if (folder.isDirectory()) {
            for (File c : folder.listFiles())
                superDelete(c);
            folder.delete();
        } else {
            folder.delete();
        }
    }

    // I hate everything about this.
    public static String buildMessage(String message) {
        return ChatColor.DARK_GRAY + "[" + ChatColor.AQUA + "DE" + ChatColor.DARK_GRAY + "]" + ChatColor.RESET + " " + message;
    }

    public static NamespacedKey parseStringToKey(String str) {
        if (!str.contains(":")) {return null;}
        String[] strs = str.split(":");
        if (strs[0].contains(":") | strs[1].contains(":")) {return null;}
        return new NamespacedKey(strs[0], strs[1]);
    }

    public static String processMacro(String macro, String[] args, HumanEntity plr) {
        switch (macro) {
            case "hand":
                ItemStack stack = plr.getInventory().getItemInMainHand();
                if (!(stack.getType() == Material.COMMAND_BLOCK)) {return "*MACRO_FAIL";}
                ItemMeta meta = stack.getItemMeta();
                if (!(meta instanceof BlockStateMeta)) {return "*MACRO_FAIL";}
                BlockStateMeta blockMeta = (BlockStateMeta) meta;
                BlockState state = blockMeta.getBlockState();
                if (!(state instanceof CommandBlock)) {return "*MACRO_FAIL";}
                CommandBlock cmdBlock = (CommandBlock) state;
                String command = cmdBlock.getCommand();
                if (command.startsWith("/")) {command = command.substring(1);} // Remove the slash
                return command;

            case "fakechat":
                if (args.length < 2) {return "*MACRO_FAIL";}
                String name = args[0];
                String[] messageArgs = Arrays.copyOfRange(args, 1, args.length);
                StringBuilder messageBuilder = new StringBuilder();
                for (String arg : messageArgs) {
                    messageBuilder.append(arg);
                    messageBuilder.append(" ");
                }
                return String.format("tellraw @a {\"text\":\"<%s> %s\"}", name, messageBuilder);

            case "fakeserver":
                if (args.length < 1) {return "*MACRO_FAIL";}
                StringBuilder messageBuilder2 = new StringBuilder();
                for (String arg : args) {
                    messageBuilder2.append(arg);
                    messageBuilder2.append(" ");
                }
                return String.format("tellraw @a {\"text\":\"[Server] %s\"}", messageBuilder2);

            case "null":
                return null;

            default:
                return "*MACRO_FAIL";
        }
    }
}
